{% extends "base.html" %}
{% load static %}
{% block title %}{{ annotation_title }} - {{ protein.protein_id }} (Architecture){% endblock %}
{% block content %}
  <script src="https://cdn.jsdelivr.net/npm/ngl@2.0.0-dev.39/dist/ngl.js"></script>
  <style>
      .architecture-view button,
.architecture-view .button {
  padding: 10px 18px;
  font-size: 0.95rem;
  font-weight: 500;
  border: 1px solid #ced4da;
  border-radius: 6px;
  background-color: #ffffff;
  color: #495057;
  cursor: pointer;
  transition: background-color 0.2s ease, border-color 0.2s ease;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.04);
}

.architecture-view button:hover,
.architecture-view .button:hover {
  background-color: #f8f9fa;
  border-color: #adb5bd;
}

.architecture-view .button.secondary {
  background-color: #f0f0f0;
  border-color: #ccc;
  color: #333;
}

.architecture-view .button.secondary:hover {
  background-color: #e6e6e6;
}

    .architecture-view .container {
      max-width: 1000px;
      margin: 0 auto;
      padding: 0 15px;
    }

    h1 {
      font-size: 1rem;
      margin-bottom: 10px;
      color: #212529;
      text-align: center;
    }

    .messages {
      list-style: none;
      padding: 0;
      margin: 15px auto;
      max-width: 800px;
      text-align: center;
    }
    .messages li {
      padding: 10px 15px;
      margin-bottom: 10px;
      border-radius: 4px;
      font-weight: bold;
    }
    .messages li.success { background-color: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
    .messages li.warning { background-color: #fff3cd; color: #856404; border: 1px solid #ffeeba; }
    .messages li.error { background-color: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
    .messages li.info { background-color: #d1ecf1; color: #0c5460; border: 1px solid #bee5eb; }

    #viewport {
      width: 100%;
      height: 55vh;
      margin: 0 auto 20px;
      border-radius: 10px;
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.1);
      background-color: white;
      position: relative;
    }

    .controls, .action-buttons {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 12px;
      margin-bottom: 15px;
      flex-wrap: wrap;
    }

    select {
      padding: 8px;
      font-size: 1rem;
      border-radius: 6px;
      border: 1px solid #ccc;
      cursor: pointer;
    }

    #domain-bar-container {
      width: 100%;
      margin: 25px 0;
    }
    #domain-bar {
      width: 100%;
      height: 30px;
      background-color: #e0e0e0;
      position: relative;
      border-radius: 6px;
      overflow: hidden;
      border: 1px solid #ccc;
    }

    .domain-segment {
      position: absolute;
      height: 100%;
      top: 0;
      cursor: pointer;
      transition: opacity 0.3s, border 0.3s;
      box-sizing: border-box;
      border: 1px solid rgba(0,0,0,0.1);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.75rem;
      font-weight: 600;
      color: #fff;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .domain-segment.wrong {
      opacity: 0.4;
      border: 2px solid red !important;
    }

    #status-message {
      text-align: center;
      margin-top: 15px;
      font-weight: bold;
    }
  </style>
<div class="architecture-view">
  <div class="container">
    <div class="page-header">
        <h1>{{ annotation_title }} - {{ protein.protein_id }}</h1>
        <div class="auth-bar">
            {% if user.is_authenticated %}
            {% else %}
                <a href="{% url 'login' %}?next={{ request.path }}">Login</a>
                <a href="{% url 'signup' %}">Sign Up</a>
            {% endif %}
        </div>
    </div>

    {% if messages %}
    <ul class="messages">
        {% for message in messages %}
        <li{% if message.tags %} class="{{ message.tags }}"{% endif %}>{{ message }}</li>
        {% endfor %}
    </ul>
    {% endif %}

    {% if csv_error %}
    <div class="messages">
      <li class="error">Warning: {{ csv_error }}</li>
    </div>
    {% endif %}

    <div id="viewport"></div>

    <div class="controls">
      <button id="toggleSpinBtn">Pause Rotation</button>
      <label for="styleSelect">Style:</label>
      <select id="styleSelect">
        <option value="cartoon">Cartoon</option>
        <option value="spacefill">Spacefill</option>
        <option value="licorice">Licorice</option>
        <option value="ball+stick">Ball+Stick</option>
        <option value="ribbon">Ribbon</option>
        <option value="trace">Trace</option>
        <option value="tube">Tube</option>
        <option value="line">Line</option>
        <option value="point">Point</option>
        <option value="backbone">Backbone</option>
        <option value="base">Base</option>
        <option value="hyperball">Hyperball</option>
      </select>
    </div>

    {% if domain_data %}
      <h2 style="text-align:center; font-size: 1.3rem; color: #444;">Domains (Click bar to mark incorrect)</h2>
      <div id="domain-bar-container">
        <div id="domain-bar"></div>
      </div>
    {% else %}
      <h2 style="text-align:center; font-size: 1.3rem; color: #444;">Domains</h2>
      <p style="text-align:center;">No domain data available to display.</p>
    {% endif %}

    <div class="action-buttons">
      <button id="saveBtn">Save & Go Next</button>
      <a href="{% url 'annotations_app:annotate_protein' folder_id=folder.id %}" id="nextBtn" class="button secondary">Skip & Go Next</a>
      <button id="undoBtn" class="button secondary">↩️ Undo Last</button>
      <a href="{% url 'annotations_app:architecture_annotation_overview' folder_id=folder.id %}" class="button secondary">Overview</a>
    </div>

    <div id="status-message"></div>
  </div>
</div>
<script>
  const domainData = {{ domain_data|default:'[]'|safe }};
  const markedWrong = {{ marked_wrong_data|safe }};





    // --- Configuration (from Django Context) ---
    const pdbUrl = "{{ pdb_url|escapejs|default:'' }}";
    const proteinPk = {{ protein.pk|default:'null' }}; // Use Protein Primary Key
    const folderId = {{ folder.id|default:'null' }};
    // URL for submitting the corrections (ensure URL name matches urls.py)
    const saveUrl = "{% url 'annotations_app:submit_domain_correction' %}";
    // URL to redirect to after successful save (goes back to find next protein)
    const nextProteinFinderUrl = "{% url 'annotations_app:annotate_protein' folder_id=folder.id %}";
    document.addEventListener("DOMContentLoaded", () => {
        const undoBtn = document.getElementById("undoBtn");
        if (undoBtn) {
            undoBtn.addEventListener("click", () => {
                fetch("{% url 'annotations_app:undo' %}", {
                    method: "POST",
                    headers: {
                        "X-CSRFToken": getCookie("csrftoken")
                    }
                })
                .then(res => res.json())
                .then(data => {
                    if (data.success) {
                        // Redirect back to the specific protein
                        const folderId = data.folder_id;
                        const proteinPk = data.protein_pk;
                        if (folderId && proteinPk) {
                            window.location.href = `/folder/${folderId}/annotate/${proteinPk}/`;
                        } else {
                            location.reload(); // Fallback reload
                        }
                    } else {
                        alert("Undo failed: " + (data.error || "Unknown error"));
                    }
                })
                .catch(err => {
                    console.error("Undo error:", err);
                    alert("Undo request failed.");
                });
            });
        }
    });


    // --- NGL and State Variables ---
    let stage;
    let currentStructureComponent = null;
    let isSpinning = true;
    const spinSpeed = 0.01;
    const spinAxis = [0, 1, 0];
    let proteinLength = 0;
    let domainIsWrong = []; // Parallel array to domainData, stores boolean status

    // --- Color Palette ---
    const colors = ["#e74c3c", "#3498db", "#2ecc71", "#f39c12", "#9b59b6", "#1abc9c", "#e67e22", "#8e44ad", "#34495e", "#f1c40f", "#c0392b", "#2980b9"];

    // --- DOM Elements ---
    const viewportDiv = document.getElementById("viewport");
    const toggleSpinBtn = document.getElementById("toggleSpinBtn");
    const styleSelect = document.getElementById("styleSelect");
    const legendDiv = document.getElementById("legend");
    const domainBarDiv = document.getElementById("domain-bar");
    const saveBtn = document.getElementById("saveBtn");
    const nextBtn = document.getElementById("nextBtn"); // The "Skip" button link
    const statusMessageDiv = document.getElementById("status-message");

    // --- Initialization ---
    document.addEventListener("DOMContentLoaded", async () => {
      // Basic checks
      if (!proteinPk || !folderId) {
          showStatus("Error: Missing protein or folder identifier. Cannot save.", "error");
          disableControls();
          return;
      }
      if (!pdbUrl && viewportDiv) {
        viewportDiv.innerHTML = "<p style='color: red; text-align:center;'>PDB file not found or path is invalid.</p>";
        // Don't necessarily disable controls if only PDB is missing but domains exist
      }
      if (!domainData || domainData.length === 0) {
          console.warn("No domain data provided for protein PK:", proteinPk);
          // Domain bar/legend are already hidden by Django template logic
      }

      // Initialize wrong status array
      domainIsWrong = new Array(domainData.length).fill(false);

      stage = new NGL.Stage("viewport", {
          backgroundColor: "white",
          fog: false
       });

      stage.setParameters({
        backgroundColor: "white",
        lightIntensity: 1.2,
        ambientColor: 0xffffff,
        cameraFov: 40,
        clipNear: 0.1,
        clipFar: 100,
        fogNear: 100,
        fogFar: 100 // force fog completely out of view
      });


      window.addEventListener("resize", () => stage.handleResize());

      try {
        if (pdbUrl) {
            console.log("Loading structure from:", pdbUrl);
            currentStructureComponent = await stage.loadFile(pdbUrl, { defaultRepresentation: false });
            console.log("Structure loaded:", currentStructureComponent);
            determineProteinLength(currentStructureComponent); // Calculate length after loading
        } else {
            console.warn("No PDB URL provided, cannot load 3D structure.");
            // Still need to calculate protein length if possible (e.g., from domains)
            determineProteinLength(null);
            viewportDiv.innerHTML = "<p style='text-align:center; color: #555;'>3D structure not available.</p>";
        }


        // Initial rendering (even if structure failed, try to show domains/bar)
        applyRepresentations(); // Renders NGL stuff if structure exists
        createDomainBar();      // Renders domain bar

        if (isSpinning && currentStructureComponent) {
          stage.setSpin(spinAxis, spinSpeed);
        }

        setupEventListeners();

      } catch (err) {
        console.error("Error during NGL setup:", err);
        if (viewportDiv) {
             viewportDiv.innerHTML = `<p style="color: red; text-align:center;">Error loading structure: ${err.message || err}</p>`;
        }
        // Decide if controls should be disabled even if structure fails but domains exist
        // disableControls();
      }
    });

    // --- Core Functions ---

    function determineProteinLength(structureComponent) {
         // Method 1: From NGL structure (if loaded)
         if (structureComponent && structureComponent.structure?.residueStore?.resno?.length > 0) {
             try {
                const resnoArray = structureComponent.structure.residueStore.resno;
                proteinLength = Math.max(...resnoArray);
                console.log("Protein length determined from NGL structure:", proteinLength);
             } catch (e) {
                 console.error("Error getting max residue number from NGL:", e);
                 proteinLength = 0; // Reset if error
             }
         }

         // Method 2: Fallback to max end from domain data
         if (proteinLength <= 0 && domainData && domainData.length > 0) {
              try {
                 proteinLength = Math.max(...domainData.map(d => d.end));
                 console.warn("Protein length estimated from max domain end:", proteinLength);
              } catch (e) {
                  console.error("Error getting max end from domain data:", e);
                  proteinLength = 0;
              }
         }

         // Final fallback
         if (proteinLength <= 0) {
             proteinLength = 1; // Avoid division by zero
             console.error("Could not determine protein length accurately. Domain bar scaling might be approximate.");
             // Optionally display a warning to the user
             // showStatus("Warning: Could not determine exact protein length. Domain bar is approximate.", "warning");
         }
    }

    function applyRepresentations() {
      if (!currentStructureComponent) return; // Exit if no structure loaded

      const style = styleSelect.value;
      currentStructureComponent.removeAllRepresentations();


      // Base representation for the whole structure
      currentStructureComponent.addRepresentation(style, {
          color: "lightgray",
          disableImpostor: true,
          disablePicking: true
        });

      // Add representation for each domain (if domainData exists)
      domainData.forEach((domain, i) => {
        const color = colors[i % colors.length];
        const selection = `${domain.start}-${domain.end}`; // NGL selection syntax

        // Check if start/end are valid numbers before adding representation
        if (typeof domain.start === 'number' && typeof domain.end === 'number' && domain.start <= domain.end) {
            currentStructureComponent.addRepresentation(style, {
              sele: selection,
              color: color,
              disableImpostor: true,
              disablePicking: true
            });


        } else {
             console.warn(`Skipping invalid domain for NGL representation: ${domain.name} (${domain.start}-${domain.end})`);
        }
      });

       // Apply auto view
       currentStructureComponent.autoView();

    }

    function createDomainBar() {
    domainBarDiv.innerHTML = ""; // Clear previous bar

    if (!domainData || domainData.length === 0) return;

    if (proteinLength <= 0) {
        console.error("Cannot create domain bar without a valid protein length.");
        const container = document.getElementById('domain-bar-container');
        if(container) container.innerHTML = "<p style='text-align:center; color: red;'>Error: Could not determine protein length for domain bar.</p>";
        return;
    }

    // Create a container for tick labels
    const tickContainer = document.createElement("div");
    tickContainer.style.position = "relative";
    tickContainer.style.height = "18px";  // space above the domain bar
    tickContainer.style.marginBottom = "5px";

    domainData.forEach((domain, index) => {
        if (typeof domain.start !== 'number' || typeof domain.end !== 'number' || domain.start <= 0 || domain.end < domain.start) {
            console.warn(`Skipping invalid domain for bar: ${domain.name} (${domain.start}-${domain.end})`);
            return;
        }

        const color = colors[index % colors.length];
        const segment = document.createElement("div");
        segment.classList.add("domain-segment");
        segment.dataset.domainIndex = index;

        const startPos = Math.max(1, domain.start);
        const leftPercent = ((startPos - 1) / proteinLength) * 100;
        const widthPercent = ((domain.end - startPos + 1) / proteinLength) * 100;

        segment.style.left = `${Math.max(0, Math.min(100, leftPercent))}%`;
        segment.style.width = `${Math.max(0, Math.min(100 - leftPercent, widthPercent))}%`;
        segment.style.backgroundColor = color;
        segment.title = `${domain.name} (${domain.start}-${domain.end}) - Click to mark incorrect`;

        // Label inside the bar
        const label = document.createElement("span");
        label.textContent = domain.name;
        label.style.color = "white";
        label.style.fontWeight = "bold";
        label.style.fontSize = "0.75rem";
        label.style.position = "absolute";
        label.style.left = "50%";
        label.style.top = "50%";
        label.style.transform = "translate(-50%, -50%)";
        label.style.whiteSpace = "nowrap";
        label.style.pointerEvents = "none";

        segment.appendChild(label);
        segment.addEventListener("click", handleDomainClick);
        domainBarDiv.appendChild(segment);

        // Create top label (start residue)
        const tick = document.createElement("div");
        tick.style.position = "absolute";
        tick.style.left = `${Math.max(0, Math.min(100, leftPercent))}%`;
        tick.style.transform = "translateX(-50%)";
        tick.style.fontSize = "0.7rem";
        tick.style.color = "#555";
        tick.textContent = domain.start;
        tickContainer.appendChild(tick);
    });

    domainBarDiv.parentElement.insertBefore(tickContainer, domainBarDiv);
        // Inside the DOMContentLoaded block, AFTER createDomainBar() has run
domainData.forEach((domain, index) => {
  const isMarked = markedWrong.some(
    d => d.name === domain.name && d.start === domain.start && d.end === domain.end
  );
  if (isMarked) {
    domainIsWrong[index] = true;
  }
});


// Apply wrong visual class manually
document.querySelectorAll('.domain-segment').forEach((segment, index) => {
  if (domainIsWrong[index]) {
    segment.classList.add("wrong");
    segment.title = `${domainData[index].name} (${domainData[index].start}-${domainData[index].end}) - Marked as INCORRECT`;
  }
});
}



    function handleDomainClick(event) {
        const segment = event.currentTarget;
        const index = parseInt(segment.dataset.domainIndex, 10);

        if (isNaN(index) || index < 0 || index >= domainIsWrong.length) return;

        // Toggle the wrong status
        domainIsWrong[index] = !domainIsWrong[index];

        // Update visual appearance
        segment.classList.toggle("wrong", domainIsWrong[index]);
        segment.title = `${domainData[index].name} (${domainData[index].start}-${domainData[index].end}) - Marked as ${domainIsWrong[index] ? 'INCORRECT' : 'correct'}`;


        console.log(`Domain ${domainData[index].name} marked as wrong: ${domainIsWrong[index]}`);
    }

    async function handleSave() {
        if (!proteinPk || !folderId) {
            showStatus("Error: Cannot save. Protein or Folder ID missing.", "error");
            return;
        }

        console.log("Saving domain corrections...");
        showStatus("Saving...", "info"); // Provide feedback
        saveBtn.disabled = true;
        nextBtn.classList.add('disabled'); // Disable skip button during save

        // 1. Identify domains marked as wrong
        const correctionsToSend = [];
        domainData.forEach((domain, index) => {
            if (domainIsWrong[index]) {
                correctionsToSend.push({
                    name: domain.name,
                    start: domain.start,
                    end: domain.end
                });
            }
        });

        // 2. Prepare data payload for the backend
        const payload = {
            protein_pk: proteinPk,
            folder_id: folderId,
            corrections: correctionsToSend // List of domains marked wrong
        };

        try {
            const csrfToken = getCookie('csrftoken');
            if (!csrfToken) {
                 throw new Error("CSRF token not found. Cannot submit form.");
            }

            const response = await fetch(saveUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': csrfToken // Include CSRF token
                },
                body: JSON.stringify(payload)
            });

            // Check response status first
            if (!response.ok) {
                let errorMsg = `Error: ${response.status} ${response.statusText}`;
                try {
                    // Try to parse error details from backend JSON response
                    const errorData = await response.json();
                    errorMsg = `Error: ${errorData.error || JSON.stringify(errorData)}`;
                    if (errorData.details) {
                         errorMsg += ` Details: ${errorData.details.join(', ')}`;
                    }
                } catch (e) { /* Ignore if response is not JSON */ }
                throw new Error(errorMsg); // Throw detailed error
            }

            // Try to parse the success response
            const result = await response.json();

            if (result.success) {
                console.log("Save successful:", result.message);
                showStatus("Save successful! Redirecting...", "success");
                // Redirect to the next protein finder URL on success
                window.location.href = nextProteinFinderUrl;
            } else {
                // Handle cases where response is ok (200) but backend indicates failure
                throw new Error(result.error || "Save request failed. Please check details.");
            }

        } catch (error) {
            console.error("Save failed:", error);
            showStatus(`Save failed: ${error.message}`, "error");
            // Re-enable buttons on failure
            saveBtn.disabled = false;
            nextBtn.classList.remove('disabled');
        }
        // 'finally' block is less useful here because of the redirect on success
    }

    // --- Event Listeners Setup ---
    function setupEventListeners() {
        if (toggleSpinBtn) {
            toggleSpinBtn.addEventListener("click", () => {
              if (!stage || !currentStructureComponent) return;
              isSpinning = !isSpinning;
              stage.setSpin(isSpinning ? spinAxis : null, isSpinning ? spinSpeed : 0);
              toggleSpinBtn.textContent = isSpinning ? "Pause Rotation" : "Resume Rotation";
            });
        }

        if (styleSelect) {
            styleSelect.addEventListener("change", () => {
              if (currentStructureComponent) {
                 applyRepresentations(); // Re-apply NGL representations with the new style
              }
            });
        }

        if (saveBtn) {
            saveBtn.addEventListener("click", handleSave);
        }

        // Optional: Add listener for "Skip" button if extra logic needed
        // if (nextBtn) {
        //    nextBtn.addEventListener('click', (e) => {
        //        // Could add a confirmation dialog here if needed
        //        console.log("Skipping to next protein finder...");
        //    });
        // }
    }

    // --- Utility Functions ---
    function disableControls() {
        if(toggleSpinBtn) toggleSpinBtn.disabled = true;
        if(styleSelect) styleSelect.disabled = true;
        if(saveBtn) saveBtn.disabled = true;
        if(nextBtn) nextBtn.classList.add('disabled'); // Add disabled style
        if(domainBarDiv) {
             domainBarDiv.style.pointerEvents = 'none'; // Disable clicks
             domainBarDiv.style.opacity = '0.6';
        }
    }

    function showStatus(message, type = "info") { // type: info, success, warning, error
        if (!statusMessageDiv) return;
        statusMessageDiv.textContent = message;
        statusMessageDiv.className = `status-${type}`; // Add class for potential styling
        statusMessageDiv.style.color = type === "error" ? "red" : (type === "success" ? "green" : (type === "warning" ? "orange" : "black"));
    }

    // Function to get CSRF token from cookies (standard Django practice)
    function getCookie(name) {
        let cookieValue = null;
        if (document.cookie && document.cookie !== '') {
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i].trim();
                if (cookie.substring(0, name.length + 1) === (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }

</script>
{% endblock %}
