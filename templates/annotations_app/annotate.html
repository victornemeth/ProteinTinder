<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Annotate Protein: {% if protein %}{{ protein.protein_id }}{% else %}Not Found{% endif %}</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', sans-serif;
            background-color: #f4f6f8;
        }

        .container {
            max-width: 960px;
            margin: 0 auto;
            padding: 30px 20px;
        }

        h1 {
            margin-bottom: 5px;
        }

        .auth-bar {
            margin-bottom: 10px;
            font-size: 0.95em;
        }

        .auth-bar a {
            text-decoration: none;
            color: #007acc;
        }

        .card-stack {
            position: relative;
            width: 100%;
            height: 500px;
            margin-top: 20px;
        }

        .card {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            border-radius: 12px;
            background: white;
            box-shadow: 0 12px 24px rgba(0, 0, 0, 0.1);
            will-change: transform;
            transition: transform 0.3s ease-out;
            touch-action: none;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .card.glow-right {
            box-shadow: 0 0 40px 10px rgba(0, 200, 0, 0.5);
        }

        .card.glow-left {
            box-shadow: 0 0 40px 10px rgba(255, 0, 0, 0.5);
        }

        .card.glow-down {
            box-shadow: 0 0 40px 10px rgba(255, 165, 0, 0.5);
        }

        .card-feedback {
            position: absolute;
            font-size: 3em;
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.2s ease;
            z-index: 10;
        }

        .feedback-right {
            color: green;
            top: 20px;
            right: 30px;
        }

        .feedback-left {
            color: red;
            top: 20px;
            left: 30px;
        }

        .feedback-down {
            color: orange;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
        }

        #pdbViewer {
            width: 100%;
            height: 100%;
        }

        .info-message, .error-message {
            padding: 10px;
            margin-top: 10px;
            font-size: 0.9em;
        }

        .error-message {
            color: red;
            border: 1px solid red;
            font-weight: bold;
        }

        .info-message {
            color: #007acc;
        }

        .swipe-instruction {
            font-size: 0.9em;
            color: #666;
            margin-top: 10px;
        }

        .undo-button {
            margin-top: 12px;
            padding: 10px 16px;
            font-size: 0.9em;
            cursor: pointer;
            background-color: #eee;
            border: none;
            border-radius: 6px;
        }

        footer {
            margin-top: 40px;
            text-align: center;
            font-size: 0.9em;
            color: #999;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/3Dmol/2.1.0/3Dmol-min.js" referrerpolicy="no-referrer"></script>
</head>
<body>
<div class="container">
    <h1>Protein Annotation Tool</h1>

    <div class="auth-bar">
        {% if user.is_authenticated %}
            Welcome, {{ user.username }} |
            <form id="logoutForm" method="post" action="{% url 'logout' %}" style="display:inline;">
    {% csrf_token %}
    <button type="submit" style="background:none;border:none;color:#007acc;cursor:pointer;padding:0;font:inherit;">
        Logout
    </button>
</form>

        {% else %}
            <a href="{% url 'login' %}?next={{ request.path }}">Login</a> |
            <a href="{% url 'signup' %}">Sign Up</a>
        {% endif %}
    </div>

    <hr>
    <h3>{{ annotation_title }}</h3>
    <p>{{ annotation_description }}</p>

    {% if protein %}
        <h2>Annotate: {{ protein.protein_id }}</h2>
        {% if protein.name %}
            <p><strong>Name:</strong> {{ protein.name }}</p>
        {% endif %}

<div class="swipe-instruction">
            üëâ Swipe right = ‚úÖ correct   |   üëà left = ‚ùå wrong   |   üîª down = ‚ùì unsure
        </div>

        <div class="card-stack">
            <div class="card" id="cardTop">
                <div class="card-feedback feedback-right" id="feedbackRight">‚úÖ</div>
                <div class="card-feedback feedback-left" id="feedbackLeft">‚ùå</div>
                <div class="card-feedback feedback-down" id="feedbackDown">‚ùì</div>
                <div id="pdbViewer">
                    {% if cleaned_pdb_path %}
                    <p class="info-message">Initializing 3D Viewer...</p>
                    {% else %}
                    <p class="error-message">Could not load PDB file path.</p>
                    {% endif %}
                </div>
            </div>
            <div class="card" style="z-index: -1; background-color: #f0f0f0;"></div>
        </div>

        <button class="undo-button" id="undoBtn">‚Ü©Ô∏è Undo Last Annotation</button>
         <!-- Add a link back to the overview -->
         <a href="{% url 'annotations_app:annotation_overview' folder_id=folder.id %}" style="margin-left: 10px; font-size: 0.9em;">Back to Overview</a>


        <script>
            document.addEventListener("DOMContentLoaded", function () {
                const viewerElement = document.getElementById("pdbViewer");
                const swipeCard = document.getElementById("cardTop");
                const undoButton = document.getElementById("undoBtn");

                const feedbackRight = document.getElementById("feedbackRight");
                const feedbackLeft = document.getElementById("feedbackLeft");
                const feedbackDown = document.getElementById("feedbackDown");

                const proteinId = "{{ protein.protein_id|escapejs }}";
                const proteinPk = "{{ protein.pk|escapejs }}"; // Use PK if needed elsewhere
                const folderId = "{{ folder.id|escapejs }}"; // Get from folder object
                // Use the cleaned path passed from the view
                const pdbFilename = "{{ cleaned_pdb_path|escapejs }}";
                const mediaUrl = "{{ media_url|escapejs }}";
                const fileUrl = pdbFilename ? mediaUrl + pdbFilename : null; // Handle null path

                const isSpecificRedo = {{ is_specific_redo|yesno:"true,false" }}; // Get flag

                // Only initialize viewer if we have a valid file path
                if (fileUrl) {
                    const viewer = $3Dmol.createViewer(viewerElement, {
                        defaultcolors: $3Dmol.elementColors.rasmol,
                        backgroundColor: 'white',
                    });

                    function animateRotation() {
                        if (viewer && viewer.rotate) { // Check if viewer exists and has rotate method
                           viewer.rotate(1);
                           viewer.render();
                           requestAnimationFrame(animateRotation);
                        }
                    }

                    const fileFormat = (() => {
                        if (!pdbFilename) return 'pdb'; // Default if no filename
                        let ext = pdbFilename.split('.').pop().toLowerCase();
                        return ext === 'ent' ? 'pdb' : (['pdb', 'cif', 'mol2', 'sdf'].includes(ext) ? ext : 'pdb');
                    })();

                    $3Dmol.download(fileUrl, viewer, { format: fileFormat })
                        .then(() => {
                            viewer.setStyle({}, { cartoon: { color: 'spectrum' } });
                            viewer.zoomTo();
                            viewer.render();
                            // Only start animation if download succeeds
                            // requestAnimationFrame(animateRotation); // Consider if animation is desired
                            viewer.zoom(1.5); // Static zoom might be better than constant rotation
                            viewer.render();

                        })
                        .catch(error => {
                            viewerElement.innerHTML = `<p class='error-message'>Error loading structure:<br>${error}</p>`;
                            console.error("3Dmol download error:", error);
                        });
                } else if (!document.querySelector('.error-message')) {
                     viewerElement.innerHTML = `<p class='error-message'>PDB file path not available.</p>`;
                }


                function submitAnnotation(direction) {
                    const emoji = direction === 'right' ? '‚úÖ' : direction === 'left' ? '‚ùå' : '‚ùì';
                    if(viewerElement) { // Ensure viewer element exists before modifying
                       viewerElement.innerHTML = `<p class='info-message'>${emoji} Annotated as ${direction.toUpperCase()}. Saving...</p>`;
                    }

                    fetch("{% url 'annotations_app:annotate' %}", { // Or use 'annotate/submit/' if you changed the URL
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json",
                            "X-CSRFToken": document.querySelector('[name=csrfmiddlewaretoken]') ? document.querySelector('[name=csrfmiddlewaretoken]').value : "{{ csrf_token }}" // More robust CSRF token retrieval
                        },
                        body: JSON.stringify({
                            protein_id: proteinId, // Keep sending protein_id (the string identifier)
                            folder_id: folderId,
                            annotation: direction
                        })
                    })
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        return response.json();
                    })
                    .then(data => {
                         if (data.success) {
                            // --- REDIRECT LOGIC ---
                            if (isSpecificRedo) {
                                // If we re-annotated a specific protein, go back to the overview
                                window.location.href = "{% url 'annotations_app:annotation_overview' folder_id=folder.id %}";
                            } else {
                                // Otherwise, load the next protein (reload the default annotation view)
                                window.location.reload();
                            }
                         } else {
                             throw new Error(data.error || "Annotation submission failed.");
                         }
                    })
                    .catch(error => {
                        console.error("Submit annotation error:", error);
                        if(viewerElement) {
                             viewerElement.innerHTML = `<p class='error-message'>Failed to save annotation: ${error}. Please try again.</p>`;
                        }
                        // Optionally reset the card after a delay on error
                        // setTimeout(resetCardPosition, 1500);
                    });
                }

                // --- UNDO BUTTON ---
                if (undoButton) { // Check if button exists
                    undoButton.addEventListener("click", () => {
                        fetch("{% url 'annotations_app:undo' %}", { // Or 'annotate/undo/'
                            method: "POST",
                            headers: {
                                "Content-Type": "application/json",
                                "X-CSRFToken": document.querySelector('[name=csrfmiddlewaretoken]') ? document.querySelector('[name=csrfmiddlewaretoken]').value : "{{ csrf_token }}"
                            }
                        }).then(response => response.json())
                          .then(data => {
                              if (data.success) {
                                // Reloading is usually fine for undo, takes you to the undone item
                                window.location.reload();
                              } else {
                                alert("Undo failed: " + (data.error || "Unknown error"));
                             }
                          })
                          .catch(error => {
                              console.error("Undo error:", error);
                              alert("Undo request failed.");
                          });
                    });
                }


                // --- SWIPE LOGIC --- (Keep existing swipe logic: startX, startY, isDragging, etc.)
                 let startX, startY, isDragging = false;

                function getSwipeDirection(dx, dy) {
                    const minDistance = 100; // Adjusted sensitivity slightly
                    const verticalThreshold = 1.5; // Make it harder to swipe down accidentally

                    if (Math.abs(dx) > Math.abs(dy) * verticalThreshold) { // Require more horizontal movement
                        if (dx > minDistance) return 'right';
                        if (dx < -minDistance) return 'left';
                    } else if (dy > Math.abs(dx) && dy > minDistance) { // Ensure downward movement is dominant and passes threshold
                         return 'down';
                    }
                    return null;
                }

                 function setCardTransform(dx, dy) {
                     if (!swipeCard) return; // Check card exists
                     const rotate = dx * 0.05;
                     swipeCard.style.transform = `translate(${dx}px, ${dy}px) rotate(${rotate}deg)`;

                     const glowThreshold = 80; // When to start showing glow/feedback

                     swipeCard.classList.remove("glow-left", "glow-right", "glow-down");
                     if (feedbackRight) feedbackRight.style.opacity = dx > glowThreshold ? '1' : '0';
                     if (feedbackLeft) feedbackLeft.style.opacity = dx < -glowThreshold ? '1' : '0';
                     if (feedbackDown) feedbackDown.style.opacity = dy > glowThreshold && Math.abs(dx) < dy ? '1' : '0'; // Prefer down if mostly vertical

                     if (dx > glowThreshold) swipeCard.classList.add("glow-right");
                     else if (dx < -glowThreshold) swipeCard.classList.add("glow-left");
                     else if (dy > glowThreshold && Math.abs(dx) < dy) swipeCard.classList.add("glow-down");
                 }

                 function resetCardPosition() {
                     if (!swipeCard) return;
                     swipeCard.style.transition = "transform 0.3s ease-out";
                     swipeCard.style.transform = `translate(0, 0) rotate(0deg)`;
                     swipeCard.classList.remove("glow-left", "glow-right", "glow-down");
                     if (feedbackRight) feedbackRight.style.opacity = '0';
                     if (feedbackLeft) feedbackLeft.style.opacity = '0';
                     if (feedbackDown) feedbackDown.style.opacity = '0';
                     // Clear transition after it finishes
                     setTimeout(() => {
                        if (swipeCard) swipeCard.style.transition = "";
                     }, 300);
                 }

                 function handleSwipeEnd(dx, dy) {
                     if (!swipeCard) return;
                     const direction = getSwipeDirection(dx, dy);
                     if (direction) {
                         // Animate card off screen before submitting
                         const offX = direction === 'right' ? window.innerWidth : (direction === 'left' ? -window.innerWidth : dx); // Keep vertical position for down swipe
                         const offY = direction === 'down' ? window.innerHeight : dy;
                         const finalRotate = dx * 0.1;

                         swipeCard.style.transition = "transform 0.4s ease-out"; // Slightly faster exit
                         swipeCard.style.transform = `translate(${offX}px, ${offY}px) rotate(${finalRotate}deg)`;

                         // Wait for animation to be visible before submitting and redirecting/reloading
                         setTimeout(() => submitAnnotation(direction), 200);
                     } else {
                         resetCardPosition();
                     }
                 }

                 // --- Event Listeners (mousedown, mousemove, etc.) ---
                if (swipeCard) { // Add checks
                    swipeCard.addEventListener('mousedown', e => {
                        if (e.target.tagName === 'BUTTON' || e.target.tagName === 'A') return; // Ignore clicks on buttons/links within card
                        isDragging = true;
                        startX = e.clientX;
                        startY = e.clientY;
                        swipeCard.style.transition = ""; // Remove transition during drag
                        e.preventDefault(); // Prevent text selection/image drag
                    });

                     document.addEventListener('mousemove', e => {
                         if (!isDragging) return;
                         const dx = e.clientX - startX;
                         const dy = e.clientY - startY;
                         setCardTransform(dx, dy);
                     });

                     document.addEventListener('mouseup', e => {
                         if (!isDragging) return;
                         isDragging = false;
                         const dx = e.clientX - startX;
                         const dy = e.clientY - startY;
                         handleSwipeEnd(dx, dy);
                     });

                     // Touch events
                     swipeCard.addEventListener('touchstart', e => {
                         if (e.target.tagName === 'BUTTON' || e.target.tagName === 'A') return;
                         if (e.touches.length === 1) { // Single touch
                             isDragging = true;
                             startX = e.touches[0].clientX;
                             startY = e.touches[0].clientY;
                             swipeCard.style.transition = "";
                             // e.preventDefault(); // Be careful with touch preventDefault, might block scrolling if needed elsewhere
                         }
                     }, { passive: true }); // Use passive where possible

                     swipeCard.addEventListener('touchmove', e => {
                         if (!isDragging || e.touches.length !== 1) return;
                         // e.preventDefault(); // Prevent scrolling while swiping card
                         const dx = e.touches[0].clientX - startX;
                         const dy = e.touches[0].clientY - startY;
                         setCardTransform(dx, dy);
                     }); // Removed passive:true as we might need preventDefault

                     swipeCard.addEventListener('touchend', e => {
                         if (!isDragging || e.changedTouches.length !== 1) return;
                         isDragging = false;
                         const dx = e.changedTouches[0].clientX - startX;
                         const dy = e.changedTouches[0].clientY - startY;
                         handleSwipeEnd(dx, dy);
                     });
                  } // End of if(swipeCard) block

            }); // End DOMContentLoaded
        </script>
    {% else %}
        <p class="info-message">No protein available for annotation or protein could not be loaded.</p>
        <a href="{% url 'annotations_app:view_folders' %}">Back to Folder List</a>
    {% endif %}

    <hr>
    <footer>
        <p><small>Annotation Tool ¬© 2025</small></p>
    </footer>
</div>
</body>
</html>
